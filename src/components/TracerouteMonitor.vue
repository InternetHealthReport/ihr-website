<script setup>
import { ref, inject, watchEffect, watch, onMounted } from 'vue'
import { QBtn, QDialog, QCard, QCardSection, QCardActions, QExpansionItem } from 'quasar'
import dagre from 'dagre'
import RipeApi from '../plugins/RipeApi'
import TracerouteChart from '@/components/charts/TracerouteChart.vue'
import TracerouteRttChart from '@/components/charts/TracerouteRttChart.vue'
import TracerouteProbesTable from '@/components/tables/TracerouteProbesTable.vue'
import TracerouteDestinationsTable from '@/components/tables/TracerouteDestinationsTable.vue'
import { isPrivateIP, calculateMedian, convertTimeToFormat, convertDateTimeToSeconds } from '../plugins/tracerouteFunctions'
import GenericCardController from '@/components/controllers/GenericCardController.vue'

const props = defineProps({
  atlasMeasurementID: {
    type: String
  },
  openOptions: {
    type: Boolean,
    default: false
  },
  probeIDs: {
    type: Array
  },
  destinationIPs: {
    type: Array
  },
  startTime: {
    type: String
  },
  stopTime: {
    type: String
  }
})

const atlas_api = inject('atlas_api')
const isLoading = ref(false)
const measurementID = ref('')
const nodes = ref({})
const edges = ref({})
const timeRange = ref({ disable: true })
const rttChartLeftTimestamp = ref(0)
const rttChartRightTimestamp = ref(0)
const nodeSize = 15
const selectedProbes = ref([])
const allProbes = ref([])
const probeDetailsMap = ref({})
const layoutNodes = ref({ nodes: {} })
const selectedDestinations = ref([])
const allDestinations = ref([])
const selectAllDestinations = ref(true)
const metaData = ref({})
const maxMedianRtt = ref(200)
const minDisplayedRtt = ref(null)
const maxDisplayedRtt = ref(null)
const asnList = ref([])
const ipToAsnMap = ref({})
const rttOverTime = ref([])
const intervalValue = ref(null)
const loadMeasurementErrorDialog = ref(false)
const loadMeasurementErrorMessage = ref('')
const nodeSet = ref(new Set())

const startTimestamp = ref(convertDateTimeToSeconds(props.startTime))
const stopTimestamp = ref(convertDateTimeToSeconds(props.stopTime))

// re-emitting events from children to grand parent
const emit = defineEmits([
  'setSelectedDestinations', 
  'setSelectedProbes', 
  'probesOverflow', 
  'setSelectedTimeRange',
])

const handleLoadMeasurementError = (error) => {
  loadMeasurementErrorMessage.value = error.message || 'An unexpected error occurred.'
  loadMeasurementErrorDialog.value = true
}

const processData = async (tracerouteData, loadProbes = false) => {
  const g = new dagre.graphlib.Graph()
  g.setGraph({ rankdir: 'LR', nodesep: 290, edgesep: 150, ranksep: 1000 })
  g.setDefaultEdgeLabel(() => ({}))

  const nonResponsiveNodes = new Set()
  const outgoingEdges = new Map()
  let highestMedianRtt = 0

  allProbes.value = allProbes.value.length == 0 ? await atlas_api.getProbesByMeasurementId(measurementID.value) : allProbes.value
  atlas_api.getProbesByIds(allProbes.value.slice(0, 1000), measurementID.value, allProbes.value.length >= 1000).then((data) => {
            data.forEach(x => {
                probeDetailsMap.value[x.id.toString()] = x
              })
            })
  atlas_api.getProbesByIds(selectedProbes.value, measurementID.value, selectedProbes.value.length >= 1000).then((data) => {
            data.forEach(x => {
                probeDetailsMap.value[x.id.toString()] = x
              })
            })

  if(allProbes.value.length > 1000) {
    emit('probesOverflow', true)
  }
  else {
    emit('probesOverflow', false)
  } 

  tracerouteData.forEach((probeData, probeIndex) => {
    if (probeData.result[0].error) {
      return
    }

    const sourceNodeId = probeData.from
    if (!g.hasNode(sourceNodeId)) {
      g.setNode(sourceNodeId, {
        label: sourceNodeId,
        width: nodeSize,
        height: nodeSize,
        isProbe: true
      })
    }

    let lastNodeId = sourceNodeId
    let finalHopNodeId = null
    let consecutiveStarCount = 0

    if (loadProbes) {
      if (
        ((!props.probeIDs ||
          props.probeIDs.length === 0 ||
          props.probeIDs.includes(probeData.prb_id.toString()))
          && !(selectedProbes.value.includes(probeData.prb_id.toString()))
        )
      ) {
        selectedProbes.value.push(probeData.prb_id.toString())
      }
    }

    if(!allDestinations.value.includes(probeData.dst_addr)) {
      allDestinations.value.push(probeData.dst_addr)
    }

    if(!(selectAllDestinations.value ||
       selectedDestinations.value.includes(probeData.dst_addr))) {
         return; 
    }

    probeData.result.forEach((hopData, hopIndex) => {
      hopData.result.forEach((result, resultIndex) => {
        let currentIp = result.from || result.x
        let isNonResponsive = false

        if (currentIp === '*') {
          consecutiveStarCount++
          if (consecutiveStarCount > 1) return
          currentIp += `-${probeIndex}-${hopIndex}-${resultIndex}`
          isNonResponsive = true
          nonResponsiveNodes.add(currentIp)
        } else {
          consecutiveStarCount = 0
        }

        if (isPrivateIP(currentIp)) {
          isNonResponsive = false
          consecutiveStarCount = 0
        }

        const nodeInfo = g.node(currentIp) || {}
        const newNodeInfo = {
          label: currentIp.replace(/-\d+-\d+-\d+$/, ''),
          width: nodeSize,
          height: nodeSize,
          isNonResponsive,
          isPrivate: isPrivateIP(currentIp),
          hops: nodeInfo.hops || [],
          asn: nodeInfo.asn || 'unknown'
        }

        if (!newNodeInfo.isNonResponsive && !nodeSet.value.has(newNodeInfo.label)) {
          nodeSet.value.add(newNodeInfo.label)
          const asnPromise = RipeApi.userASN(newNodeInfo.label).then((asnData) => {
            const asn = asnData.data.data.asns[0]
            if (asn) {
              if (!asnList.value.includes(asn)) {
                asnList.value.push(asn)
              }
              ipToAsnMap.value[newNodeInfo.label] = asn
            }
          })
        }

        newNodeInfo.hops.push({
          from: result.from,
          rtt: result.rtt,
          size: result.size,
          ttl: result.ttl
        })

        if (result.rtt !== undefined && result.rtt !== null) {
          rttOverTime.value.push({ timestamp: probeData.timestamp, rtt: result.rtt })
        }

        const medianRtt = calculateMedian(newNodeInfo.hops.map((hop) => hop.rtt))
        if (medianRtt > highestMedianRtt) {
          highestMedianRtt = medianRtt
        }

        g.setNode(currentIp, newNodeInfo)

        if (
          lastNodeId &&
          currentIp &&
          lastNodeId !== currentIp &&
          !g.hasEdge(currentIp, lastNodeId)
        ) {
          if (!g.hasEdge(lastNodeId, currentIp)) {
            g.setEdge(lastNodeId, currentIp)
            if (!outgoingEdges.has(lastNodeId)) {
              outgoingEdges.set(lastNodeId, [])
            }
            outgoingEdges.get(lastNodeId).push(currentIp)
          }
        }
        lastNodeId = currentIp
        finalHopNodeId = currentIp
      })
    })

    if (finalHopNodeId && g.hasNode(finalHopNodeId)) {
      const nodeInfo = g.node(finalHopNodeId)
      g.setNode(finalHopNodeId, { ...nodeInfo, isLastHop: true })
    }
  })

  nonResponsiveNodes.forEach((nodeId) => {
    if (!outgoingEdges.has(nodeId)) {
      g.removeNode(nodeId)
    }
  })

  dagre.layout(g)

  const nodesMap = {}
  const edgesMap = {}
  const layouts = { nodes: {} }

  g.nodes().forEach((nodeId) => {
    const nodeInfo = g.node(nodeId)
    nodesMap[nodeId] = { name: nodeInfo.label, ...nodeInfo }
    layouts.nodes[nodeId] = { x: nodeInfo.x, y: nodeInfo.y }
  })

  g.edges().forEach((edge) => {
    const edgeInfo = g.edge(edge)
    edgesMap[`${edge.v}-${edge.w}`] = { source: edge.v, target: edge.w }
  })

  nodes.value = nodesMap
  edges.value = edgesMap
  layoutNodes.value = layouts

  maxMedianRtt.value = highestMedianRtt

  updateDisplayedRttValues()
}

const updateDisplayedRttValues = () => {
  let minRtt = Infinity
  let maxRtt = -Infinity
  let destinationNodeMedianRtt = null

  Object.values(nodes.value).forEach((node) => {
    if (node.hops && node.hops.length > 0) {
      const medianRtt = calculateMedian(
        node.hops.map((hop) => hop.rtt).filter((rtt) => rtt !== undefined)
      )
      if (medianRtt !== null) {
        minRtt = Math.min(minRtt, medianRtt)
        if (node.isLastHop) {
          destinationNodeMedianRtt = medianRtt
        }
      }
    }
  })

  minDisplayedRtt.value = minRtt === Infinity ? null : minRtt
  maxDisplayedRtt.value =
    destinationNodeMedianRtt !== null
      ? destinationNodeMedianRtt
      : maxRtt === -Infinity
        ? null
        : maxRtt
}

watch(nodes, updateDisplayedRttValues)

const loadMeasurement = async () => {
  measurementID.value = props.atlasMeasurementID
  nodes.value = {}
  edges.value = {}

  metaData.value = {}
  timeRange.value = { disable: true }
  rttChartLeftTimestamp.value = 0
  rttChartRightTimestamp.value = 0

  selectedProbes.value = []
  allProbes.value = []
  probeDetailsMap.value = {}

  layoutNodes.value = { nodes: {} }
  selectedDestinations.value = []
  allDestinations.value = []
  asnList.value = []
  ipToAsnMap.value = {}

  rttOverTime.value = []
  intervalValue.value = null

  if (measurementID.value.trim()) {
    isLoading.value = true
    try {
      const fetchedMetaData = (await atlas_api.getMeasurementById(measurementID.value)).data

      metaData.value = fetchedMetaData

      if (fetchedMetaData.status.name === 'Ongoing') {
        fetchedMetaData.stop_time = Math.floor(Date.now() / 1000)
      }

      const stopTime = (stopTimestamp.value !== 0)? stopTimestamp : metaData.value.stop_time

      // Fetch last 5 measurements
      const shortenedDurationStartTime = stopTime - 5*metaData.value["interval"]
      const startTime = (startTimestamp.value !== 0) ? 
                          startTimestamp
                          : shortenedDurationStartTime > 0 ?
                            shortenedDurationStartTime
                              : metaData.value.start_time 


      timeRange.value.min = startTime
      timeRange.value.max = stopTime

      rttChartLeftTimestamp.value = startTime
      rttChartRightTimestamp.value = stopTime

      timeRange.value.disable = false

      intervalValue.value = fetchedMetaData.interval || null

      await loadMeasurementData(true)

      if(selectedDestinations.value === null || selectedDestinations.value.length === 0) {
        selectedDestinations.value = allDestinations.value
        selectAllDestinations.value = true
      } else {
        selectAllDestinations.value = null
      }
    } catch (error) {
      console.log(error)
      handleLoadMeasurementError(error)
    } finally {
      isLoading.value = false
    }
  }
}

const loadMeasurementData = async (loadProbes = false) => {
  if (measurementID.value.trim()) {
    isLoading.value = true
    try {
      if (loadProbes) {
        allProbes.value = []
        allDestinations.value = []
      }

      const params = {}

      if (!timeRange.value.disable) {
        params.start = timeRange.value.min
        params.stop = timeRange.value.max
      }

      if (selectedProbes.value.length > 0) {
        params.probe_ids = selectedProbes.value.join(',')
      }
      const data = await atlas_api.getAndCacheMeasurementDataInChunks(measurementID.value, params)

      processData(data, loadProbes)
    } catch (error) {
      console.error('Failed to load measurement data:', error)
    } finally {
      isLoading.value = false
    }
  }
}

const debounce = (func, wait) => {
  let timeout
  return (...args) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      func.apply(this, args)
    }, wait)
  }
}

const loadMeasurementOnTimeRange = debounce((e) => {
  if(e.min !== 0 && e.max !== 0) {
    const queryParamObject = { 
      startTime: convertTimeToFormat(e.min), 
      stopTime: convertTimeToFormat(e.max) 
    }
    emit('setSelectedTimeRange', (queryParamObject))
  }
  rttChartLeftTimestamp.value = e.min
  rttChartRightTimestamp.value = e.max

  // On slider update, update the measurement data
  timeRange.value.min = e.min
  timeRange.value.max = e.max
  loadMeasurementData()
}, 3000)

const loadMeasurementOnProbeChange = debounce(() => {
  loadMeasurementData()
}, 1000)

const loadMeasurementOnDestinationChange = debounce(() => {
  loadMeasurementData()
}, 1000)

const loadMeasurementOnSearchQuery = debounce(() => {
  loadMeasurementData()
}, 1000)

const sortAndCompare = (arrA, arrB) => {
  if(arrA.length !== arrB.length) {
    return false
  }

  const N = arrA.length
  const compareFunc = (a, b) => +a - +b
  const sortedArrA = arrA.sort(compareFunc)
  const sortedArrB = arrB.sort(compareFunc)

  for(let i = 0; i < N; i++) {
    if(sortedArrA[i] !== sortedArrB[i]) {
      return false
    }
  }

  return true
}


watchEffect(() => {
  if (selectedProbes.value.length > 0) {
    loadMeasurementOnProbeChange()
    if(!sortAndCompare(props.probeIDs, selectedProbes.value)) {
      emit('setSelectedProbes', selectedProbes.value)
    }
  }
})

watch(() => props.probeIDs, (newArr, oldArr) => {
  if(!sortAndCompare(newArr, oldArr) &&
    !sortAndCompare(newArr, selectedProbes.value) 
  ) {
    selectedProbes.value = newArr
  }
})

watch(() => props.destinationIPs, () => {
  selectedDestinations.value = props.destinationIPs
})

watch(() => props.startTime, () => {
  startTimestamp.value = convertDateTimeToSeconds(props.startTime)
})

watch(() => props.stopTime, () => {
  stopTimestamp.value = convertDateTimeToSeconds(props.stopTime)
})

watchEffect(() => {
  if (!timeRange.value.disable) {
    loadMeasurementOnTimeRange(timeRange.value)
  }
})

watchEffect(() => {
  if (selectedDestinations.value.length > 0) {
    loadMeasurementOnDestinationChange()
    emit('setSelectedDestinations', selectedDestinations.value)
  }
})

const setSelectedProbes = (value) => {
  selectedProbes.value = value
}

const setSelectedDestinations = (value) => {
  selectedDestinations.value = value
}

const setSelectAllDestinations = (value) => {
  selectAllDestinations.value = value
}

watch(
  () => props.atlasMeasurementID,
  () => {
    loadMeasurement()
  }
)
</script>

<template>
  <GenericCardController
    :title="$t('tracerouteMonitorChart.title')"
    :sub-title="$t('tracerouteMonitorChart.subTitle')"
    :info-title="$t('tracerouteMonitorChart.info.title')"
    :info-description="$t('tracerouteMonitorChart.info.description')"
  >
    <TracerouteChart
      :measurement-i-d="measurementID"
      :is-loading="isLoading"
      :nodes="nodes"
      :selected-probes="selectedProbes"
      :node-size="nodeSize"
      :edges="edges"
      :layout-nodes="layoutNodes"
      :meta-data="metaData"
      :probe-details-map="probeDetailsMap"
      :min-displayed-rtt="minDisplayedRtt"
      :max-displayed-rtt="maxDisplayedRtt"
      :ip-to-asn-map="ipToAsnMap"
      :asn-list="asnList"
      @update-displayed-rtt-values="updateDisplayedRttValues"
    />
    <QExpansionItem :default-opened="props.openOptions" icon="tune" label="Options">
      <GenericCardController
        :title="$t('tracerouteMonitorRtt.title')"
        :sub-title="$t('tracerouteMonitorRtt.subTitle')"
        :info-title="$t('tracerouteMonitorRtt.info.title')"
        :info-description="$t('tracerouteMonitorRtt.info.description')"
        class="cardTraceroute"
      >
        <TracerouteRttChart
          :interval-value="intervalValue"
          :time-range="timeRange"
          :meta-data="metaData"
          :left-timestamp="rttChartLeftTimestamp"
          :right-timestamp="rttChartRightTimestamp"
          :rtt-over-time="rttOverTime"
          @load-measurement-on-time-range="loadMeasurementOnTimeRange"
        />
      </GenericCardController>
      <GenericCardController
        :title="$t('tracerouteMonitorProbes.title')"
        :sub-title="$t('tracerouteMonitorProbes.subTitle')"
        :info-title="$t('tracerouteMonitorProbes.info.title')"
        :info-description="$t('tracerouteMonitorProbes.info.description')"
        class="cardTraceroute"
      >
        <TracerouteProbesTable
          :nodes="nodes"
          :all-probes="allProbes"
          :probe-details-map="probeDetailsMap"
          :selected-probes="selectedProbes"
          @set-selected-probes="setSelectedProbes"
          @load-measurement-on-search-query="loadMeasurementOnSearchQuery"
        />
      </GenericCardController>
      <GenericCardController
        :title="$t('tracerouteMonitorDestinations.title')"
        :sub-title="$t('tracerouteMonitorDestinations.subTitle')"
        :info-title="$t('tracerouteMonitorDestinations.info.title')"
        :info-description="$t('tracerouteMonitorDestinations.info.description')"
      >
        <TracerouteDestinationsTable
          :nodes="nodes"
          :all-destinations="allDestinations"
          :select-all-destinations="selectAllDestinations"
          :ip-to-asn-map="ipToAsnMap"
          :selected-destinations="selectedDestinations"
          @set-selected-destinations="setSelectedDestinations"
          @set-select-all-destinations="setSelectAllDestinations"
          @load-measurement-on-search-query="loadMeasurementOnSearchQuery"
        />
      </GenericCardController>
    </QExpansionItem>
  </GenericCardController>
</template>

<style scoped>
.cardTraceroute {
  margin-bottom: 20px;
}
</style>
