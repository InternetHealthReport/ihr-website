<script setup>
import { QBtn, QSpinner, QBtnToggle } from 'quasar'
import { ref, watch, computed, nextTick, inject } from 'vue'
import { VNetworkGraph } from 'v-network-graph'
import * as vNG from 'v-network-graph'
import { isPrivateIP, calculateMedian } from '../../plugins/tracerouteFunctions'
import '@/styles/chart.css'

const props = defineProps({
  measurementID: {
    type: String
  },
  isLoading: {
    type: Boolean
  },
  nodes: {
    type: Object
  },
  selectedProbes: {
    type: Array
  },
  nodeSize: {
    type: Number
  },
  edges: {
    type: Object
  },
  layoutNodes: {
    type: Object
  },
  metaData: {
    type: Object
  },
  probeDetailsMap: {
    type: Object
  },
  minDisplayedRtt: {
    type: Number
  },
  maxDisplayedRtt: {
    type: Number
  },
  ipToAsnMap: {
    type: Object
  },
  asnList: {
    type: Array
  }
})

const emit = defineEmits(['updateDisplayedRttValues'])

const ripe_api = inject('ripe_api')
const tooltipData = ref({})
const zoomLevel = ref(0)
const selectedNode = ref(null)
const displayMode = ref('normal')
const targetNodeId = ref('')
const graph = ref()
const tooltip = ref()
const tooltipOpacity = ref(0)
const tooltipPos = ref({ left: '0px', top: '0px' })
const highlightedEdges = ref({})
const asnColors = ref({})
const showAsnOverlay = ref(true)

const configs = computed(() => {
  assignAsnColors()
  return vNG.defineConfigs({
    node: {
      selectable: true,
      normal: {
        radius: props.nodeSize / 2,
        color: (node) => {
          if (displayMode.value === 'rtt') {
            if (node.hops && node.hops.length > 0) {
              const medianRtt = calculateMedian(node.hops.map((hop) => hop.rtt))
              return rttColor(medianRtt)
            } else {
              return 'black'
            }
          }
          if (displayMode.value === 'asn') {
            const asn = props.ipToAsnMap[node.label] || 'unknown'
            return asnColors.value[asn] || 'black'
          }
          if (node.isProbe) return 'green'
          if (node.isNonResponsive) return 'gray'
          if (node.isLastHop) return 'red'
          if (isPrivateIP(node.label)) return 'purple'
          return 'blue'
        }
      }
    },
    edge: {
      normal: {
        color: (edge) =>
          highlightedEdges.value[`${edge.source}-${edge.target}`] ? 'orange' : '#aaa',
        width: (edge) => (highlightedEdges.value[`${edge.source}-${edge.target}`] ? 3 : 1),
        margin: 4,
        type: 'curve',
        gap: 40
      }
    }
  })
})

const eventHandlers = {
  'node:pointerover': ({ node }) => {},
  'node:pointerout': () => {},
  'view:click': () => {
    clearHighlight()
    selectedNode.value = null
    tooltipOpacity.value = 0
  },
  'node:pointerdown': async ({ node }) => {
    clearHighlight()
    highlightPath(node)

    selectedNode.value = node
    targetNodeId.value = node

    await nextTick()

    const nodeInfo = props.nodes[node]
    let nodeMetaData
    if (!node.includes('*')) {
      nodeMetaData = (await ripe_api.prefixOverview(node)).data
      if (nodeMetaData.error === 'LOCAL_STORAGE_FULL') {
        return handleLocalStorageFullError()
      }
    }
    const rttValues = nodeInfo.hops?.map((hop) => hop.rtt)
    const sizeValues = nodeInfo.hops?.map((hop) => hop.size)
    const ttlValues = nodeInfo.hops?.map((hop) => hop.ttl)

    let nodeType = 'Normal'
    let color = 'blue'
    if (nodeInfo.isProbe) {
      nodeType = 'Probe'
      color = 'green'
    }
    if (nodeInfo.isNonResponsive) {
      nodeType = 'Non Responsive'
      color = 'gray'
    }
    if (nodeInfo.isLastHop) {
      nodeType = 'Destination'
      color = 'red'
    }
    if (nodeInfo.isPrivate) {
      nodeType = 'Private'
      color = 'purple'
    }

    let probeDetails
    Object.keys(props.probeDetailsMap).forEach((probeId) => {
      if (
        props.probeDetailsMap[probeId].address_v4 === node ||
        props.probeDetailsMap[probeId].address_v6 === node
      ) {
        probeDetails = props.probeDetailsMap[probeId]
      }
    })

    tooltipData.value = {
      label: nodeInfo.label,
      medianRtt: calculateMedian(rttValues),
      medianSize: calculateMedian(sizeValues),
      medianTtl: calculateMedian(ttlValues),
      type: nodeType,
      color: color,
      ...nodeMetaData,
      ...probeDetails
    }
    tooltipOpacity.value = 1

    await nextTick()

    if (tooltip.value) {
      const tooltipHeight = tooltip.value.offsetHeight
      const domPoint = graph.value.translateFromSvgToDomCoordinates(targetNodePos.value)
      tooltipPos.value = {
        left: `${domPoint.x - tooltip.value.offsetWidth / 2}px`,
        top: `${domPoint.y - props.nodeSize - tooltipHeight - 10}px`
      }
    }
  }
}

const getRandomColor = () => {
  const letters = '0123456789ABCDEF'
  let color = '#'
  for (let i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)]
  }
  return color
}

const assignAsnColors = () => {
  const colors = {}
  props.asnList.forEach((asn) => {
    colors[asn] = getRandomColor()
  })
  asnColors.value = colors
}

const rttColor = (rtt, shouldCompliment = true) => {
  if (rtt === null || rtt === undefined) return 'black'
  const normalized = Math.min(Math.max(rtt / props.maxDisplayedRtt, 0), 1)
  const greenFactor = shouldCompliment ? 1 - normalized : normalized
  const green = Math.floor(255 * greenFactor)
  return `rgb(150, ${green}, 60)`
}

const highlightPath = (startNodeId) => {
  const path = []
  const visited = new Set()
  const queue = [[startNodeId, []]]

  while (queue.length > 0) {
    const [currentNodeId, currentPath] = queue.shift()

    if (visited.has(currentNodeId)) {
      continue
    }

    visited.add(currentNodeId)
    currentPath.push(currentNodeId)

    const outgoingEdges = Object.values(props.edges).filter((edge) => edge.source === currentNodeId)
    if (outgoingEdges.length === 0) {
      path.push(
        ...currentPath
          .map((node, index) => {
            if (index < currentPath.length - 1) {
              return `${node}-${currentPath[index + 1]}`
            }
          })
          .filter((edge) => edge)
      )
      break
    }

    outgoingEdges.forEach((edge) => {
      if (!visited.has(edge.target)) {
        queue.push([edge.target, [...currentPath]])
      }
    })
  }

  highlightedEdges.value = Object.fromEntries(path.map((edgeId) => [edgeId, true]))
}

const filteredAsnList = computed(() => {
  const visibleAsns = new Set()
  Object.values(props.nodes).forEach((node) => {
    const asn = props.ipToAsnMap[node.label]
    if (asn) {
      visibleAsns.add(asn)
    }
  })
  return Array.from(visibleAsns)
})

const clearHighlight = () => {
  highlightedEdges.value = {}
}

const zoomIn = () => {
  zoomLevel.value *= 1.2
}

const zoomOut = () => {
  zoomLevel.value *= 0.8
}

const toggleFullScreen = () => {
  const graphContainer = document.querySelector('.graph-container')
  if (!document.fullscreenElement) {
    graphContainer.requestFullscreen().then(() => {
      graphContainer.style.background = 'white'
    })
  } else {
    document.exitFullscreen().then(() => {
      graphContainer.style.background = 'white'
    })
  }
}

const targetNodePos = computed(() => {
  const nodePos = props.layoutNodes.nodes[targetNodeId.value]
  return nodePos || { x: 0, y: 0 }
})

watch(
  () => [targetNodePos.value, tooltipOpacity.value],
  () => {
    if (!graph.value || !tooltip.value) return
    const domPoint = graph.value.translateFromSvgToDomCoordinates(targetNodePos.value)
    tooltipPos.value = {
      left: domPoint.x - tooltip.value.offsetWidth / 2 + 'px',
      top: domPoint.y - props.nodeSize - tooltip.value.offsetHeight - 10 + 'px'
    }
  },
  { deep: true }
)

watch(
  () => props.measurementID,
  () => {
    selectedNode.value = null
    displayMode.value = 'normal'
    highlightedEdges.value = {}
    asnColors.value = {}
    showAsnOverlay.value = true
  }
)

watch(displayMode, () => {
  emit('updateDisplayedRttValues')
})
</script>

<template>
  <div class="graph-container">
    <VNetworkGraph
      v-if="Object.keys(nodes).length > 0 && selectedProbes.length > 0 && !isLoading"
      ref="graph"
      v-model:zoom-level="zoomLevel"
      :nodes="nodes"
      :edges="edges"
      :layouts="layoutNodes"
      :configs="configs"
      :event-handlers="eventHandlers"
    />
    <div v-else-if="!isLoading" class="placeholder-message">
      No Traceroute Network Graph data available.
    </div>
    <div
      v-if="selectedNode"
      ref="tooltip"
      class="tooltip"
      :style="{ ...tooltipPos, opacity: tooltipOpacity }"
    >
      <div style="display: flex; align-items: center">
        <span class="nodeTypeDot" :style="{ backgroundColor: tooltipData.color }" />{{
          tooltipData.type
        }}
      </div>
      <div style="padding-bottom: 5px">
        <template v-if="tooltipData?.data?.asns[0]?.asn">
          <div style="display: flex; align-items: center">
            <span
              class="asnDot"
              :style="{ backgroundColor: asnColors[tooltipData.data.asns[0].asn] || 'gray' }"
            ></span>
            <a :href="`/en/network/AS${tooltipData.data.asns[0].asn}`" target="_blank">
              AS{{ tooltipData.data.asns[0].asn }} ({{ tooltipData.data.asns[0].holder }})
            </a>
          </div>
        </template>
        <template v-else> ASN not available </template>
      </div>
      <div><strong>IP:</strong> {{ tooltipData.label }}</div>
      <div><strong>Announced:</strong> {{ tooltipData?.data?.announced ?? 'Not available' }}</div>
      <div>
        <strong>Prefix:</strong> {{ tooltipData?.data?.block?.resource ?? 'Not available' }}
      </div>
      <div>
        <strong>Description:</strong> {{ tooltipData?.data?.block?.desc ?? 'Not available' }}
      </div>
      <div><strong>Name:</strong> {{ tooltipData?.data?.block?.name ?? 'Not available' }}</div>
      <div v-if="tooltipData.address_v4">
        <strong>IPv4 Address:</strong> {{ tooltipData.address_v4 }}
      </div>
      <div v-if="tooltipData.address_v6">
        <strong>IPv6 Address:</strong> {{ tooltipData.address_v6 }}
      </div>
      <div v-if="tooltipData.country_code">
        <strong>Country Code:</strong> {{ tooltipData.country_code }}
      </div>
      <div v-if="tooltipData.asn_v4"><strong>ASN4:</strong> {{ tooltipData.asn_v4 }}</div>
      <div v-if="tooltipData.asn_v6"><strong>ASN6:</strong> {{ tooltipData.asn_v6 }}</div>
      <div>
        <strong>Median RTT:</strong>
        {{ tooltipData.medianRtt ? tooltipData.medianRtt + 'ms' : 'Not available' }}
      </div>
      <div>
        <strong>Median Size:</strong>
        {{ tooltipData.medianSize ? tooltipData.medianSize + ' bytes' : 'Not available' }}
      </div>
      <div><strong>Median TTL:</strong> {{ tooltipData.medianTtl ?? 'Not available' }}</div>
      <div v-if="tooltipData.id"><strong>Probe ID:</strong> {{ tooltipData.id }}</div>
      <div v-if="tooltipData.description">
        <strong>Probe Description:</strong> {{ tooltipData.description }}
      </div>
      <div v-if="tooltipData.status?.name">
        <strong>Status:</strong> {{ tooltipData.status.name }}
      </div>
      <div v-if="tooltipData.status?.since">
        <strong>Status Since:</strong> {{ new Date(tooltipData.status.since).toLocaleString() }}
      </div>
    </div>
    <div v-if="Object.keys(nodes).length > 0" class="mode-toggle-overlay">
      <div>
        <QBtnToggle
          v-model="displayMode"
          :options="[
            { label: 'Normal Mode', value: 'normal' },
            { label: 'RTT Mode', value: 'rtt' },
            { label: 'ASN Mode', value: 'asn' }
          ]"
        />
      </div>
    </div>
    <div v-if="displayMode === 'rtt' && Object.keys(nodes).length > 0" class="legend">
      <div class="row items-center">
        <div class="col">
          <div class="rttLabel">RTT</div>
        </div>
        <div class="col">
          <div class="scaleLabel">{{ `${maxDisplayedRtt.toFixed(3)}ms` }}</div>
          <div class="scale">
            <div
              v-for="(percentage, index) in Array.from(
                { length: 10 },
                (_, i) => minDisplayedRtt + (i * (maxDisplayedRtt - minDisplayedRtt)) / 9
              )"
              :key="index"
              class="scaleColor"
              :style="{ backgroundColor: rttColor(percentage, (shouldCompliment = false)) }"
            ></div>
          </div>
          <div class="scaleLabel">{{ `${minDisplayedRtt.toFixed(3)}ms` }}</div>
        </div>
      </div>
    </div>
    <div v-if="Object.keys(nodes).length > 0" class="row view-control-overlay justify-center">
      <QBtn icon="zoom_in" @click="zoomIn" />
      <QBtn icon="zoom_out" @click="zoomOut" />
      <QBtn icon="fullscreen" @click="toggleFullScreen" />
    </div>
    <div v-if="isLoading" class="IHR_loading-spinner">
      <QSpinner color="secondary" size="15em" />
    </div>
  </div>
</template>

<style>
.graph-container {
  height: 55vh;
  position: relative;
}

.placeholder-message {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  color: #666;
  font-size: 1.2em;
}

.tooltip {
  padding: 1em;
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  width: 30em;
  font-size: 12px;
  background-color: #fff0bd;
  border: 1px solid #ffb950;
  box-shadow: 2px 2px 2px #aaa;
  transition: opacity 0.2s linear;
  z-index: 10;
}

.nodeTypeDot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  margin-right: 5px;
}

.measurement-info-overlay {
  position: absolute;
  top: 0;
  left: 0;
  background: rgba(255, 255, 255, 0.8);
  padding: 10px;
  border-bottom: 1px solid #ccc;
  border-right: 1px solid #ccc;
  font-size: 12px;
}

.mode-toggle-overlay {
  position: absolute;
  top: 0;
  left: 0;
  background-color: rgba(255, 255, 255, 0.8);
}

.rtt-info-overlay {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  border-right: 1px solid #ccc;
  background: rgba(255, 255, 255, 0.8);
  padding: 10px;
  border-bottom: 1px solid #ccc;
  border-left: 1px solid #ccc;
  font-size: 12px;
  z-index: 1;
}

.rtt-dot {
  display: inline-block;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  margin-right: 5px;
}

.legend {
  text-align: center;
  position: absolute;
  z-index: 1;
  top: 30%;
  right: 1%;
}

.rttLabel {
  transform: rotate(-90deg);
  font-size: 17px;
  font-weight: bold;
  margin-left: 50%;
}

.scaleLabel {
  font-size: 14px;
  text-align: center;
}

.scaleColor {
  flex: 1;
  width: 100%;
}

.asn-info-overlay {
  position: absolute;
  top: 0;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 255, 255, 0.8);
  padding: 10px;
  border-bottom: 1px solid #ccc;
  border-left: 1px solid #ccc;
  border-right: 1px solid #ccc;
  font-size: 12px;
  display: flex;
  flex-direction: column;
  z-index: 1;
}

.asn-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 1em;
}

.asn-box {
  padding: 0.2em;
  text-align: center;
  font-size: 0.9em;
}

.asn-link {
  color: #fff;
  text-shadow: 1px 1px 2.5px rgba(0, 0, 0, 0.5);
}

.view-control-overlay {
  background-color: rgba(255, 255, 255, 0.8);
  position: absolute;
  bottom: 0px;
  display: flex;
  flex-direction: row;
  gap: 0.5em;
}

.scale {
  display: flex;
  flex-direction: column;
  height: 180px;
  border: 1px solid #ccc;
  margin-left: 30%;
  margin-right: 30%;
}

.asnDot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  margin-right: 5px;
}
</style>
